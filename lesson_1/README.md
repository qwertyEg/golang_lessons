# Массивы и слайсы в Go

Привет! Сегодня мы научимся работать с массивами и срезами в языке Go!

## Оглавление
1. [Массивы](#массивы)
2. [Слайсы](#слайсы)

---

## Массивы

Массивы в Go — это одна из базовых структур данных, представляющая собой фиксированную последовательность элементов одного типа. В этом разделе мы подробно рассмотрим, как работают массивы, почему они статичны, приведем примеры их использования и объясним, почему в Go массивы используются реже, чем слайсы.

### Что такое массив?

Массив — это коллекция элементов одного типа, которые хранятся в памяти последовательно. Ключевая особенность массивов в Go — их фиксированная длина. Длина массива является частью его типа, что означает, что массивы разной длины — это разные типы данных.

### Синтаксис

```go
[<length>]<type>{...elements}
```

### Так можно объявить массив:

```go
var arr [5]int // Массив из 5 целых чисел
```

Здесь:

- [5]int — тип массива, где 5 — длина массива, 
- int — тип элементов.
- arr — переменная, которая хранит массив.

### Еще пример объявления массива:

```go
cities := [5]string{"Москва", "Долгопрудный"}
```

- объявлен массив строк;
- длина массива — 5 элементов;
- заполнены 2 элемента: «Москва» и «Долгопрудный»;
- оставшиеся 3 места представляют собой значение для строк по умолчанию - пустую строку.

### И еще один пример объявления массива:
```go
var arr [5]int // Массив из 5 целых чисел
arr[0] = 1
arr[1] = 2
fmt.Println(arr) // [1 2 0 0 0]
```

### Особенности массивов

**1.Фиксированная длина**

Длина массива задается при его создании и не может быть изменена. Это делает массивы статичными. Например:

```go
var arr [3]int // Массив из 3 элементов
arr[0] = 1
arr[1] = 2
arr[2] = 3
// arr[3] = 4 // Ошибка: выход за пределы массива
```

Попытка добавить элемент за пределы длины массива приведет к ошибке компиляции.

**2. Значения по умолчанию**

При создании массива все его элементы инициализируются нулевыми значениями для соответствующего типа. Например:

```go
var arr [3]int
fmt.Println(arr) // [0 0 0]
```

Для строк:

```go
var strArr [2]string
fmt.Println(strArr) // ["" ""]
```

**3. Копирование массивов**

При присваивании одного массива другому создается полная копия данных. Это означает, что изменения в одном массиве не влияют на другой.

```go
arr1 := [3]int{1, 2, 3}
arr2 := arr1 // Копирование массива
arr2[0] = 100
fmt.Println(arr1) // [1 2 3]
fmt.Println(arr2) // [100 2 3]
```

### Примеры работы с массивами

**Инициализация массива**

Массив можно инициализировать при объявлении:

```go
arr := [3]int{1, 2, 3}
fmt.Println(arr) // [1 2 3]
```

Если количество элементов меньше длины массива, остальные элементы заполняются нулевыми значениями:

```go
arr := [5]int{1, 2} // [1 2 0 0 0]
fmt.Println(arr)
```

**Использование ... для автоматического определения длины**

Если вы не хотите указывать длину массива явно, можно использовать ...:

```go
arr := [...]int{1, 2, 3, 4, 5}
fmt.Println(arr) // [1 2 3 4 5]
fmt.Println(len(arr)) // 5
```

**3. Итерация по массиву**

Для перебора элементов массива используется цикл for:

```go
arr := [3]int{10, 20, 30}
for i := 0; i < len(arr); i++ {
    fmt.Println(arr[i])
}
```

Или с использованием range:

```go
for index, value := range arr {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
}
```

### Почему массивы статичны?

Массивы в Go статичны, потому что:

- Длина массива является частью его типа. Например, [3]int и [5]int — это разные типы данных.
- Память для массива выделяется на этапе компиляции. Это делает массивы эффективными с точки зрения производительности, но ограничивает их гибкость.
- Невозможно изменить размер массива после его создания. Если вам нужно добавить или удалить элементы, придется создавать новый массив.

На самом деле на практике массивы в go используются реже слайсов.

### Задача 1: Сумма элементов массива

Условие:

Создайте массив из 5 целых чисел. Напишите программу, которая вычисляет сумму всех элементов массива и выводит результат.

Пример:

```go
arr := [5]int{1, 2, 3, 4, 5}
// Ответ: 15
```

### Задача 2: Поиск максимального элемента

Условие:

Создайте массив из 7 целых чисел. Напишите программу, которая находит максимальный элемент в массиве и выводит его.

Пример:

```go
arr := [7]int{3, 7, 2, 9, 5, 1, 6}
// Максимальный элемент: 9
```

### Задача 3: Поиск индекса элемента

Условие:

Создайте массив из 8 целых чисел. Напишите программу, которая находит индекс первого вхождения заданного числа в массиве. Если число не найдено, выведите -1.

Пример:

```go
arr := [8]int{5, 3, 8, 1, 9, 4, 7, 2}
num := 9
// Индекс: 4
```

### Задача 4: Реверс массива

Условие:

Создайте массив из 6 целых чисел. Напишите программу, которая переворачивает массив (первый элемент становится последним, второй — предпоследним и т.д.) и выводит результат.

Пример:

```go
arr := [6]int{1, 2, 3, 4, 5, 6}
// Реверс: [6 5 4 3 2 1]
```
## Слайсы

Слайсы (slices) в Go — это динамические и гибкие структуры данных, которые представляют собой "окно" в массив. Они позволяют работать с последовательностями данных переменной длины, что делает их более удобными и мощными, чем массивы. В этом разделе мы подробно рассмотрим слайсы, их создание, особенности и преимущества.

### 1. Что такое слайс?

Слайс — это структура данных, которая содержит:

- Указатель на базовый массив (ссылка на массив, в котором хранятся данные).
- Длину (length) — количество элементов, которые слайс содержит.
- Емкость (capacity) — максимальное количество элементов, которые можно хранить в слайсе без выделения новой памяти.

Слайсы являются динамическими, то есть их длина и емкость могут изменяться во время выполнения программы.

### 2. Создание слайсов

**Слайс можно создать, "вырезав" часть массива с помощью синтаксиса [начало:конец].**

```go
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:4] // Слайс включает элементы с индексами 1, 2, 3
fmt.Println(slice) // [2 3 4]
```

- arr[1:4] создает слайс, который ссылается на элементы массива с индексами от 1 до 3 (включительно).
- Слайс не копирует данные, а ссылается на них.

**Способ 2: Создание слайса с помощью make**

Функция make позволяет создать слайс с заданной длиной и емкостью.

```go
slice := make([]int, 3, 5) // Слайс с длиной 3 и емкостью 5
fmt.Println(slice) // [0 0 0]
fmt.Println(len(slice)) // 3
fmt.Println(cap(slice)) // 5
```
- make([]int, 3, 5) создает слайс типа []int с длиной 3 и емкостью 5.
- Элементы слайса инициализируются нулевыми значениями.

- Базовый массив: ```[0, 0, 0, _, _]``` (длина массива = 5)
- Слайс:          ```[0, 0, 0] ```      (len=3, cap=5)

**Способ 3: Создание слайса с помощью литерала**

Слайс можно создать, указав его элементы напрямую.

```go
slice := []int{1, 2, 3, 4, 5}
fmt.Println(slice) // [1 2 3 4 5]
```

**Способ 4: Создание пустого слайса**

Пустой слайс можно создать, указав тип данных.

```go
var slice []int
fmt.Println(slice) // []
fmt.Println(len(slice)) // 0
fmt.Println(cap(slice)) // 0
```

- var slice []int создает пустой слайс с нулевой длиной и емкостью.


### 3. Особенности слайсов

**1. Слайсы ссылаются на массивы**
Слайс не хранит данные самостоятельно, а ссылается на базовый массив. Это означает, что изменения в слайсе влияют на базовый массив и наоборот.

```go
arr := [3]int{1, 2, 3}
slice := arr[:] // Слайс ссылается на весь массив
slice[0] = 100
fmt.Println(arr) // [100 2 3]
```

**2. Длина и емкость**

- Длина (length) — количество элементов в слайсе.
- Емкость (capacity) — максимальное количество элементов, которые можно хранить в слайсе без выделения новой памяти.

**3. Изменение размера слайса**

Слайс может изменять свой размер с помощью функции append. Если емкость превышена, Go выделяет новый массив и копирует туда данные.

```go
slice := []int{1, 2, 3}
slice = append(slice, 4, 5)
fmt.Println(slice) // [1 2 3 4 5]
fmt.Println(len(slice)) // 5
fmt.Println(cap(slice)) // 6 (емкость увеличивается автоматически)
```


### 4. Преимущества слайсов перед массивами

- Динамический размер: Слайсы могут изменять свой размер во время выполнения программы, что делает их более гибкими, чем массивы.
- Удобство работы: Слайсы поддерживают множество встроенных операций, таких как добавление (append), копирование (copy) и срезы (slicing).
- Эффективность: Слайсы работают с данными через ссылки, что позволяет избежать копирования больших объемов данных.
- Широкое использование в стандартной библиотеке: ольшинство функций в стандартной библиотеке Go работают со слайсами, а не с массивами.

### 5. Примеры работы со слайсами

**Пример 1: Добавление элементов**

```go
slice := []int{1, 2, 3}
slice = append(slice, 4, 5)
fmt.Println(slice) // [1 2 3 4 5]
```

**Пример 2: Копирование слайса**

```go
src := []int{1, 2, 3}
dst := make([]int, len(src))
copy(dst, src)
fmt.Println(dst) // [1 2 3]
```

**Пример 3: Срезы**

```go
slice := []int{1, 2, 3, 4, 5}
subSlice := slice[1:3] // [2 3]
fmt.Println(subSlice)
```

**Пример 4: Изменение слайса**

```go
slice := []int{1, 2, 3}
slice[0] = 100
fmt.Println(slice) // [100 2 3]
```

**Пример 5: Удаление элементов**

Чтобы удалить элемент из среза, требуется создать срез без включения удаляемого элемента.

Пример

```go
letters := []string{"A", "B", "C", "D", "E"}
remove := 2 // индекс элемента для удаления
letters = append(letters[:remove], letters[remove+1:]...) // результат: {"A", "B", "D", "E"}
```

Три точки в Go называются вариадичной нотацией многоточие (ellipsis), которая в разных контекстах имеет разный смысл. В данном контексте они используются для развёртывания содержимого среза.

Разберём по частям:


```letters[:remove]``` — это срез, содержащий все элементы от начала массива до индекса remove (не включая remove).

```letters[remove+1:]``` — это срез, содержащий все элементы, начиная с индекса remove+1 и до конца массива.

```append(letters[:remove], letters[remove+1:]...)``` — функция append принимает два параметра:

Первый: исходный срез, в который требуется добавить элементы.
Второй: элементы, которые нужно добавить.
Оператор ... «разворачивает» срез letters[remove+1:], чтобы передать его элементы по отдельности в функцию append. Без ... срез передавался бы как единый объект, что вызвало бы ошибку.

Зачем это нужно?

Оператор ```...``` позволяет передавать отдельные элементы среза, как если бы они были перечислены явно:
```append(letters[:remove], "D", "E", "F")```
Этот код эквивалентен:
```append(letters[:remove], letters[remove+1:]...)```


### 6. Реаллокация

**Когда вы добавляете новый элемент в слайс с помощью функции append, и текущая длина слайса (len) становится больше его емкости (cap), Go выполняет следующие действия:**

- Создает новый массив с увеличенной емкостью.
- Копирует все элементы из старого массива в новый.
- Обновляет указатель слайса, чтобы он ссылался на новый массив.
- Увеличивает длину и емкость слайса.
- Этот процесс называется реаллокацией (reallocation).


## Задачки

### Задача 5: Сумма элементов слайса

**Условие: Создайте слайс из 5 целых чисел. Напишите программу, которая вычисляет сумму всех элементов слайса и выводит результат.**

Пример:

```go
slice := []int{1, 2, 3, 4, 5}
// Сумма: 15
```

### Задача 6: Поиск максимального элемента

**Условие: Создайте слайс из 7 целых чисел. Напишите программу, которая находит максимальный элемент в слайсе и выводит его.**

Пример:

```go
slice := []int{3, 7, 2, 9, 5, 1, 6}
// Максимальный элемент: 9

```

### Задача 7: Поиск минимального элемента

**Условие: Создайте слайс из 6 целых чисел. Напишите программу, которая находит минимальный элемент в слайсе и выводит его.**

Пример: 

```go
slice := []int{10, 4, 8, 2, 7, 3}
// Минимальный элемент: 2
```

### Задача 8: Подсчет четных и нечетных чисел

**Создайте слайс из 10 целых чисел. Напишите программу, которая подсчитывает количество четных и нечетных чисел в слайсе и выводит результат.**

Пример: 

```go
slice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
// Четные: 5, Нечетные: 5
```


### Задача 9: Удаление элемента по индексу

**Условие: Создайте слайс из 5 целых чисел. Напишите программу, которая удаляет элемент по заданному индексу и выводит результат.**

Пример:

```go
slice := []int{1, 2, 3, 4, 5}
index := 2
// Результат: [1, 2, 4, 5]
```






